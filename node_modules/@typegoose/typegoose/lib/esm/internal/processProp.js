import { deprecate, format } from 'util';
import { logger } from '../logSettings';
import { buildSchema, mongoose } from '../typegoose';
import { DecoratorKeys, WhatIsIt } from './constants';
import { schemas } from './data';
import { InvalidPropError, InvalidTypeError, NotAllVPOPElementsError, NotNumberTypeError, NotStringTypeError } from './errors';
import * as utils from './utils';
/**
 * Function that is the actual processing of the prop's (used for caching)
 * @param input All the options needed for prop's
 */
export function processProp(input) {
    var _a, _b, _c;
    const { key, target } = input;
    const name = utils.getName(target);
    const rawOptions = Object.assign({}, input.options);
    let Type = Reflect.getMetadata(DecoratorKeys.Type, target, key);
    const propKind = (_a = input.whatis) !== null && _a !== void 0 ? _a : detectWhatIsIt(Type);
    logger.debug('Starting to process "%s.%s"', utils.getName(target), key);
    utils.assertion(typeof key === 'string', new Error(format('Property Key in typegoose cannot be an symbol! (%s.%s)', name, key)));
    optionDeprecation(rawOptions);
    {
        // soft errors & "type"-alias mapping
        switch (propKind) {
            case WhatIsIt.NONE:
                if ('items' in rawOptions) {
                    logger.warn('You might not want to use option "items" for an non-array @prop type (%s.%s)', utils.getName(target), key);
                }
                if ('of' in rawOptions) {
                    logger.warn('You might not want to use option "of" for an non-map @prop type (%s.%s)', utils.getName(target), key);
                }
                break;
            case WhatIsIt.ARRAY:
                if ('items' in rawOptions) {
                    rawOptions.type = rawOptions.items;
                    delete rawOptions.items;
                }
                if ('of' in rawOptions) {
                    logger.warn('You might not want to use option "of" where the "design:type" is "Array" (%s.%s)', utils.getName(target), key);
                }
                // set the "Type" to undefined, if "ref" or "refPath" are defined, otherwise the "refType" will be wrong
                if ((('ref' in rawOptions) || ('refPath' in rawOptions)) && !('type' in rawOptions)) {
                    Type = undefined;
                }
                break;
            case WhatIsIt.MAP:
                if ('of' in rawOptions) {
                    rawOptions.type = rawOptions.of;
                    delete rawOptions.of;
                }
                if ('items' in rawOptions) {
                    logger.warn('You might not want to use option "items" where the "design:type" is "Map" (%s.%s)', name, key);
                }
                break;
        }
    }
    if (!utils.isNullOrUndefined(rawOptions.type)) {
        logger.info('Prop Option "type" is set to', rawOptions.type);
        Type = utils.getType(rawOptions.type);
        delete rawOptions.type;
    }
    // prevent "infinite" buildSchema loop / Maximum Stack size exceeded
    if (Type === target.constructor) {
        throw new TypeError('It seems like the type used is the same as the target class, which is not supported\n' +
            `Please look at https://github.com/typegoose/typegoose/issues/42 for more information`);
    }
    // map to correct buffer type, otherwise it would result in "Mixed"
    if (Type === mongoose.Types.Buffer) {
        Type = mongoose.Schema.Types.Buffer;
    }
    if (utils.isNotDefined(Type)) {
        buildSchema(Type);
    }
    if ('discriminators' in rawOptions) {
        logger.debug('Found option "discriminators" in "%s.%s"', name, key);
        const discriminators = utils.getType(rawOptions.discriminators)
            .map((val, index) => {
            if (utils.isConstructor(val)) {
                return { type: val };
            }
            if (typeof val === 'object') {
                if (!('type' in val)) {
                    throw new Error(format('"%s.%s" discriminator index "%s" is an object, but does not contain the "type" property!', name, key, index));
                }
                return val;
            }
            throw new Error(format('"%s.%s" discriminators index "%s" is not an object or an constructor!', name, key, index));
        });
        const disMap = new Map((_b = Reflect.getMetadata(DecoratorKeys.NestedDiscriminators, target.constructor)) !== null && _b !== void 0 ? _b : []);
        disMap.set(key, discriminators);
        Reflect.defineMetadata(DecoratorKeys.NestedDiscriminators, disMap, target.constructor);
        delete rawOptions.discriminators;
    }
    // allow setting the type asynchronously
    if (!utils.isNullOrUndefined(rawOptions.ref)) {
        rawOptions.ref = utils.getType(rawOptions.ref);
        utils.assertion(!utils.isNullOrUndefined(rawOptions.ref), new Error(format('Option "ref" for "%s.%s" was defined with an arrow-function, but the function returned null/undefined!', name, key)));
        rawOptions.ref = typeof rawOptions.ref === 'string' ? rawOptions.ref : utils.getName(rawOptions.ref);
    }
    if (utils.isWithVirtualPOP(rawOptions)) {
        if (!utils.includesAllVirtualPOP(rawOptions)) {
            throw new NotAllVPOPElementsError(name, key);
        }
        const virtuals = new Map((_c = Reflect.getMetadata(DecoratorKeys.VirtualPopulate, target.constructor)) !== null && _c !== void 0 ? _c : []);
        virtuals.set(key, rawOptions);
        Reflect.defineMetadata(DecoratorKeys.VirtualPopulate, virtuals, target.constructor);
        return;
    }
    const schemaProp = utils.initProperty(name, key, propKind);
    if (!utils.isNullOrUndefined(rawOptions.set) || !utils.isNullOrUndefined(rawOptions.get)) {
        utils.assertion(typeof rawOptions.set === 'function', new TypeError(`"${name}.${key}" does not have a set function!`));
        utils.assertion(typeof rawOptions.get === 'function', new TypeError(`"${name}.${key}" does not have a get function!`));
        /*
         * Note:
         * this doesn't have a check if prop & returntype of the function is the same,
         * because it can't be accessed at runtime
         */
        schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), { type: Type }), rawOptions);
        return;
    }
    // use "Type" if it is an suitable ref-type, otherwise default back to "ObjectId"
    const refType = utils.isAnRefType(Type) ? Type : mongoose.Schema.Types.ObjectId;
    if ('ref' in rawOptions) {
        utils.assertion(!utils.isNullOrUndefined(rawOptions.ref), new Error(format('Options "ref" is set, but is undefined/null! (%s.%s)', name, key)));
        const ref = rawOptions.ref;
        delete rawOptions.ref;
        switch (propKind) {
            case WhatIsIt.ARRAY:
                schemaProp[key] = utils.createArrayFromDimensions(rawOptions, Object.assign(Object.assign(Object.assign({}, schemaProp[key][0]), { type: refType, ref }), rawOptions), name, key);
                break;
            case WhatIsIt.NONE:
                schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), { type: refType, ref }), rawOptions);
                break;
            default:
                throw new TypeError(format('"ref" is not supported for "%s"! (%s, %s)', propKind, utils.getName(target), key));
        }
        return;
    }
    const refPath = rawOptions.refPath;
    if (refPath) {
        utils.assertion(typeof refPath === 'string', new TypeError(format('"refPath" for "%s, %s" should be of type String!', utils.getName(target), key)));
        delete rawOptions.refPath;
        switch (propKind) {
            case WhatIsIt.ARRAY:
                schemaProp[key] = utils.createArrayFromDimensions(rawOptions, Object.assign(Object.assign(Object.assign({}, schemaProp[key][0]), { type: refType, refPath }), rawOptions), name, key);
                break;
            case WhatIsIt.NONE:
                schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), { type: refType, refPath }), rawOptions);
                break;
            default:
                throw new TypeError(format('"refPath" is not supported for "%s"! (%s, %s)', propKind, utils.getName(target), key));
        }
        return;
    }
    // check if Type is actually a real working Type
    if (utils.isNullOrUndefined(Type) || typeof Type !== 'function') {
        throw new InvalidTypeError(name, key, Type);
    }
    const enumOption = rawOptions.enum;
    if (!utils.isNullOrUndefined(enumOption)) {
        // check if the supplied value is already "mongoose-consumeable"
        if (!Array.isArray(enumOption)) {
            if (Type === String || Type === mongoose.Schema.Types.String) {
                rawOptions.enum = Object.entries(enumOption) // get all key-value pairs of the enum
                    // no reverse-filtering because if it is full of strings, there is no reverse mapping
                    .map(([enumKey, enumValue]) => {
                    // convert key-value pairs to an mongoose-usable enum
                    // safeguard, this should never happen because TypeScript only sets "design:type" to "String"
                    // if the enum is full of strings
                    if (typeof enumValue !== 'string') {
                        throw new NotStringTypeError(name, key, enumKey, typeof enumValue);
                    }
                    return enumValue;
                });
            }
            else if (Type === Number || Type === mongoose.Schema.Types.Number) {
                rawOptions.enum = Object.entries(enumOption) // get all key-value pairs of the enum
                    // filter out the "reverse (value -> name) mappings"
                    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings
                    .filter(([enumKey, enumValue], _i, arr) => {
                    // safeguard, this should never happen because typescript only sets "design:type" to "Number"
                    // if the enum is full of numbers
                    if (utils.isNullOrUndefined(enumValue) || arr.findIndex(([k]) => k === enumValue.toString()) <= -1) {
                        // if there is no reverse mapping, throw an error
                        throw new NotNumberTypeError(name, key, enumKey, typeof enumValue);
                    }
                    return typeof enumValue === 'number';
                })
                    .map(([enumKey, enumValue]) => {
                    // convert key-value pairs to an mongoose-useable enum
                    if (typeof enumValue !== 'number') {
                        throw new NotNumberTypeError(name, key, enumKey, typeof enumValue);
                    }
                    return enumValue;
                });
            }
            else {
                // this will happen if the enum type is not "String" or "Number"
                // most likely this error happened because the code got transpiled with babel or "tsc --transpile-only"
                throw new Error(`Invalid type used for enums!, got: "${Type}" (${name}.${key})`
                    + 'Is the code transpiled with Babel or \'tsc --transpile-only\' or \'ts-node --transpile-only\'?\n'
                    + 'See https://typegoose.github.io/typegoose/docs/api/decorators/prop/#enum');
            }
        }
    }
    if (!utils.isNullOrUndefined(rawOptions.addNullToEnum)) {
        rawOptions.enum = Array.isArray(rawOptions.enum) ? rawOptions.enum : [];
        rawOptions.enum.push(null);
        delete rawOptions.addNullToEnum;
    }
    {
        // check for validation inconsistencies
        if (utils.isWithStringValidate(rawOptions) && !utils.isString(Type)) {
            throw new NotStringTypeError(name, key);
        }
        // check for transform inconsistencies
        if (utils.isWithStringTransform(rawOptions) && !utils.isString(Type)) {
            throw new NotStringTypeError(name, key);
        }
        if (utils.isWithNumberValidate(rawOptions) && !utils.isNumber(Type)) {
            throw new NotNumberTypeError(name, key);
        }
    }
    /** Is this Type (/Class) in the schemas Map? */
    const isInSchemas = schemas.has(utils.getName(Type));
    if (!isInSchemas && !utils.isPrimitive(Type) && !utils.isObject(Type)) {
        throw new InvalidPropError(Type.name, key); // This seems to be never thrown!
    }
    if (utils.isPrimitive(Type)) {
        if (utils.isObject(Type, true)) {
            utils.warnMixed(target, key);
        }
        switch (propKind) {
            case WhatIsIt.ARRAY:
                schemaProp[key] = Object.assign(Object.assign({}, schemaProp[key][0]), utils.mapArrayOptions(rawOptions, Type, target, key));
                return;
            case WhatIsIt.MAP:
                const mapped = utils.mapOptions(rawOptions, Type, target, key);
                schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), mapped.outer), { type: Map, of: Object.assign({ type: Type }, mapped.inner) });
                return;
            case WhatIsIt.NONE:
                schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), rawOptions), { type: Type });
                return;
            default:
                throw new Error(`"${propKind}"(whatis(primitive)) is invalid for "${name}.${key}"`);
        }
    }
    // If the 'Type' is not a 'Primitive Type' and no subschema was found treat the type as 'Object'
    // so that mongoose can store it as nested document
    if (utils.isObject(Type) && !isInSchemas) {
        utils.warnMixed(target, key);
        logger.warn('if someone can see this message, please open an new issue at https://github.com/typegoose/typegoose/issues with reproduction code for tests');
        schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), rawOptions), { type: mongoose.Schema.Types.Mixed });
        return;
    }
    const virtualSchema = buildSchema(Type);
    switch (propKind) {
        case WhatIsIt.ARRAY:
            schemaProp[key] = Object.assign(Object.assign({}, schemaProp[key][0]), utils.mapArrayOptions(rawOptions, virtualSchema, target, key, Type));
            return;
        case WhatIsIt.MAP:
            const mapped = utils.mapOptions(rawOptions, virtualSchema, target, key, Type);
            schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), mapped.outer), { type: Map, of: Object.assign({ type: virtualSchema }, mapped.inner) });
            return;
        case WhatIsIt.NONE:
            schemaProp[key] = Object.assign(Object.assign(Object.assign({}, schemaProp[key]), rawOptions), { type: virtualSchema });
            return;
        default:
            throw new Error(`"${propKind}"(whatis(subSchema)) is invalid for "${name}.${key}"`);
    }
}
/**
 * Check for deprecated options, and if needed process them
 * @param options
 */
function optionDeprecation(options) {
    if ('refType' in options) {
        options.type = options.refType;
        delete options.refType;
        deprecate(() => undefined, 'Option "refType" is deprecated, use option "type"', 'TDEP0003')();
    }
    if ('of' in options) {
        deprecate(() => undefined, 'Option "of" is deprecated, use option "type"', 'TDEP0003')();
    }
    if ('items' in options) {
        deprecate(() => undefined, 'Option "items" is deprecated, use option "type"', 'TDEP0003')();
    }
}
/**
 * Detect "WhatIsIt" based on "Type"
 * @param Type The Type used for detection
 */
function detectWhatIsIt(Type) {
    logger.debug('Detecting WhatIsIt');
    if (Type === Array ||
        Type === mongoose.Types.Array ||
        Type === mongoose.Schema.Types.Array ||
        Type === mongoose.Types.DocumentArray ||
        Type === mongoose.Schema.Types.DocumentArray) {
        return WhatIsIt.ARRAY;
    }
    if (Type === Map || Type === mongoose.Types.Map || Type === mongoose.Schema.Types.Map) {
        return WhatIsIt.MAP;
    }
    return WhatIsIt.NONE;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvY2Vzc1Byb3AuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvaW50ZXJuYWwvcHJvY2Vzc1Byb3AudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDekMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hDLE9BQU8sRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBU3JELE9BQU8sRUFBRSxhQUFhLEVBQUUsUUFBUSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDakMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLHVCQUF1QixFQUFFLGtCQUFrQixFQUFFLGtCQUFrQixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQy9ILE9BQU8sS0FBSyxLQUFLLE1BQU0sU0FBUyxDQUFDO0FBRWpDOzs7R0FHRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQUMsS0FBZ0M7O0lBQzFELE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDO0lBQzlCLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkMsTUFBTSxVQUFVLEdBQWlCLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsRSxJQUFJLElBQUksR0FBb0IsT0FBTyxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztJQUNqRixNQUFNLFFBQVEsU0FBRyxLQUFLLENBQUMsTUFBTSxtQ0FBSSxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFdEQsTUFBTSxDQUFDLEtBQUssQ0FBQyw2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