import { mergeWith, omit } from 'lodash';
import * as mongoose from 'mongoose';
import { format } from 'util';
import { logger } from '../logSettings';
import { DecoratorKeys, Severity, WhatIsIt } from './constants';
import { constructors, globalOptions, schemas } from './data';
import { NoValidClass } from './errors';
/**
 * Returns true, if the type is included in mongoose.Schema.Types
 * @param Type The Type
 * @returns true, if it includes it
 */
export function isPrimitive(Type) {
    if (typeof (Type === null || Type === void 0 ? void 0 : Type.name) === 'string') {
        // try to match "Type.name" with all the Property Names of "mongoose.Schema.Types"
        // (like "String" with "mongoose.Schema.Types.String")
        return (Object.getOwnPropertyNames(mongoose.Schema.Types).includes(Type.name) ||
            // try to match "Type.name" with all "mongoose.Schema.Types.*.name"
            // (like "SchemaString" with "mongoose.Schema.Types.String.name")
            Object.values(mongoose.Schema.Types).findIndex((v) => v.name === Type.name) >= 0);
    }
    return false;
}
/**
 * Returns true, if the type is included in mongoose.Schema.Types except the aliases
 * @param Type The Type
 * @returns true, if it includes it
 */
export function isAnRefType(Type) {
    if (typeof (Type === null || Type === void 0 ? void 0 : Type.name) === 'string') {
        // Note: this is not done "once" because types can be added as custom types
        const tmp = Object.getOwnPropertyNames(mongoose.Schema.Types).filter((x) => {
            switch (x) {
                case 'Oid':
                case 'Bool':
                case 'Object':
                case 'Boolean':
                    return false;
                default:
                    return true;
            }
        });
        // try to match "Type.name" with all the Property Names of "mongoose.Schema.Types" except the ones with aliases
        // (like "String" with "mongoose.Schema.Types.String")
        return (tmp.includes(Type.name) ||
            // try to match "Type.name" with all "mongoose.Schema.Types.*.name"
            // (like "SchemaString" with "mongoose.Schema.Types.String.name")
            Object.values(mongoose.Schema.Types).findIndex((v) => v.name === Type.name) >= 0);
    }
    return false;
}
/**
 * Returns true, if it is an Object
 * @param Type The Type
 * @param once Just run it once?
 * @returns true, if it is an Object
 */
export function isObject(Type, once = false) {
    if (typeof (Type === null || Type === void 0 ? void 0 : Type.name) === 'string') {
        let prototype = Type.prototype;
        let name = Type.name;
        while (name) {
            if (name === 'Object' || name === 'Mixed') {
                return true;
            }
            if (once) {
                break;
            }
            prototype = Object.getPrototypeOf(prototype);
            name = prototype === null || prototype === void 0 ? void 0 : prototype.constructor.name;
        }
    }
    return false;
}
/**
 * Returns true, if it is an Number
 * @param Type The Type
 * @returns true, if it is an Number
 */
export function isNumber(Type) {
    var _a;
    const name = (_a = Type === null || Type === void 0 ? void 0 : Type.name) !== null && _a !== void 0 ? _a : '';
    return name === 'Number' || name === mongoose.Schema.Types.Number.name;
}
/**
 * Returns true, if it is an String
 * @param Type The Type
 * @returns true, if it is an String
 */
export function isString(Type) {
    var _a;
    const name = (_a = Type === null || Type === void 0 ? void 0 : Type.name) !== null && _a !== void 0 ? _a : '';
    return name === 'String' || name === mongoose.Schema.Types.String.name;
}
/**
 * Initialize the property in the schemas Map
 * @param name Name of the current Model/Class
 * @param key Key of the property
 * @param whatis What should it be for a type?
 */
export function initProperty(name, key, whatis) {
    const schemaProp = !schemas.has(name) ? schemas.set(name, {}).get(name) : schemas.get(name);
    switch (whatis) {
        case WhatIsIt.ARRAY:
            schemaProp[key] = [{}];
            break;
        case WhatIsIt.MAP:
        case WhatIsIt.NONE:
            schemaProp[key] = {};
            break;
        default:
            /* istanbul ignore next */ // ignore because this case should really never happen (typescript prevents this)
            throw new TypeError('"whatis" is not supplied OR doesn\'t have a case yet!');
    }
    return schemaProp;
}
/**
 * Get the Class for a given Document
 * @param document The Document
 */
export function getClassForDocument(document) {
    const modelName = document.constructor.modelName;
    return constructors.get(modelName);
}
/**
 * Get the Class for a given Schema
 * @param input
 */
export function getClass(input) {
    if (typeof input === 'string') {
        return constructors.get(input);
    }
    if (typeof (input === null || input === void 0 ? void 0 : input.typegooseName) === 'string') {
        return constructors.get(input.typegooseName);
    }
    if (typeof (input === null || input === void 0 ? void 0 : input.typegooseName) === 'function') {
        return constructors.get(input.typegooseName());
    }
    throw new ReferenceError('Input was not a string AND didnt have a .typegooseName function AND didnt have a .typegooseName string');
}
/**
 * Return true if there are Options
 * @param options The raw Options
 */
export function isWithStringValidate(options) {
    var _a, _b;
    return !isNullOrUndefined((_b = (_a = options.match) !== null && _a !== void 0 ? _a : options.minlength) !== null && _b !== void 0 ? _b : options.maxlength);
}
/**
 * Return true if there are Options
 * @param options The raw Options
 */
export function isWithStringTransform(options) {
    var _a, _b;
    return !isNullOrUndefined((_b = (_a = options.lowercase) !== null && _a !== void 0 ? _a : options.uppercase) !== null && _b !== void 0 ? _b : options.trim);
}
/**
 * Return true if there are Options
 * @param options The raw Options
 */
export function isWithNumberValidate(options) {
    var _a;
    return !isNullOrUndefined((_a = options.min) !== null && _a !== void 0 ? _a : options.max);
}
const virtualOptions = ['localField', 'foreignField'];
/**
 * Check if Options include Virtual Populate Options
 * @param options RawOptions of the Prop
 */
export function isWithVirtualPOP(options) {
    return Object.keys(options).some((v) => virtualOptions.includes(v));
}
export const allVirtualoptions = virtualOptions.slice(0); // copy "virtualOptions" array
allVirtualoptions.push('ref');
/**
 * Check if All the required Options are present
 * @param options RawOptions of the Prop
 */
export function includesAllVirtualPOP(options) {
    return allVirtualoptions.every((v) => Object.keys(options).includes(v));
}
/**
 * Merge value & existing Metadata & Save it to the class
 * Difference with "mergeMetadata" is that this one DOES save it to the class
 * @param key Metadata key
 * @param value Raw value
 * @param cl The constructor
 * @internal
 */
export function assignMetadata(key, value, cl) {
    if (isNullOrUndefined(value)) {
        return value;
    }
    const newValue = mergeMetadata(key, value, cl);
    Reflect.defineMetadata(key, newValue, cl);
    return newValue;
}
/**
 * Merge value & existing Metadata
 * Difference with "assignMetadata" is that this one DOES NOT save it to the class
 * @param key Metadata key
 * @param value Raw value
 * @param cl The constructor
 * @internal
 */
export function mergeMetadata(key, value, cl) {
    assertion(typeof key === 'string', new TypeError(`"${key}"(key) is not a string! (mergeMetadata)`));
    assertionIsClass(cl);
    // Please don't remove the other values from the function, even when unused - it is made to be clear what is what
    return mergeWith({}, Reflect.getMetadata(key, cl), value, (_objValue, srcValue, ckey, _object, _source, _stack) => customMerger(ckey, srcValue));
}
/**
 * Used for lodash customizer's (cloneWith, cloneDeepWith, mergeWith)
 * @param key the key of the current object
 * @param val the value of the object that should get returned for "existingMongoose" & "existingConnection"
 */
function customMerger(key, val) {
    if (typeof key !== 'string') {
        return undefined;
    }
    if (/^(existingMongoose|existingConnection)$/.test(key)) {
        return val;
    }
    return undefined;
}
/**
 * Merge only schemaOptions from ModelOptions of the class
 * @param value The value to use
 * @param cl The Class to get the values from
 */
export function mergeSchemaOptions(value, cl) {
    return mergeMetadata(DecoratorKeys.ModelOptions, { schemaOptions: value }, cl).schemaOptions;
}
/**
 * Tries to return the right target
 * if target.constructor.name is "Function", return target, otherwise target.constructor
 * @param target The target to determine
 */
export function getRightTarget(target) {
    var _a;
    return ((_a = target.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Function' ? target : target.constructor;
}
/**
 * Get the correct name of the class's model
 * (with suffix)
 * @param cl The Class
 */
export function getName(cl) {
    var _a, _b, _c, _d, _e, _f;
    const ctor = getRightTarget(cl);
    const options = (_a = Reflect.getMetadata(DecoratorKeys.ModelOptions, ctor)) !== null && _a !== void 0 ? _a : {};
    const baseName = ctor.name;
    if ((_b = options.options) === null || _b === void 0 ? void 0 : _b.automaticName) {
        const suffix = (_d = (_c = options.options) === null || _c === void 0 ? void 0 : _c.customName) !== null && _d !== void 0 ? _d : (_e = options.schemaOptions) === null || _e === void 0 ? void 0 : _e.collection;
        return !isNullOrUndefined(suffix) ? `${baseName}_${suffix}` : baseName;
    }
    if (typeof ((_f = options.options) === null || _f === void 0 ? void 0 : _f.customName) === 'string') {
        if (options.options.customName.length <= 0) {
            throw new TypeError(`"customName" must be a string AND at least one character ("${baseName}")`);
        }
        return options.options.customName;
    }
    return baseName;
}
/**
 * Returns if it is not defined in "schemas"
 * @param cl The Type
 */
export function isNotDefined(cl) {
    return (typeof cl === 'function'
        && !isPrimitive(cl)
        && cl !== Object
        && !schemas.has(getName(cl)));
}
/**
 * Map Options to "inner" & "outer"
 * -> inner: means inner of "type: [{here})"
 * -> outer: means outer of "type: [{}], here"
 *
 * Specific to Arrays
 * @param rawOptions The raw options
 * @param Type The Type of the array
 * @param target The Target class
 * @param pkey Key of the Property
 * @param loggerType Type to use for logging
 */
export function mapArrayOptions(rawOptions, Type, target, pkey, loggerType) {
    logger.debug('mapArrayOptions called');
    loggerType = loggerType !== null && loggerType !== void 0 ? loggerType : Type;
    if (!(Type instanceof mongoose.Schema)) {
        loggerType = Type;
    }
    const mapped = mapOptions(rawOptions, Type, target, pkey, loggerType);
    /** The Object that gets returned */
    const returnObject = Object.assign(Object.assign({}, mapped.outer), { type: [
            Object.assign({ type: Type }, mapped.inner)
        ] });
    returnObject.type = createArrayFromDimensions(rawOptions, returnObject.type, getName(target), pkey);
    if (loggerType) {
        logger.debug('(Array) Final mapped Options for Type "%s"', getName(loggerType), returnObject);
    }
    return returnObject;
}
/**
 * Map Options to "inner" & "outer"
 * @param rawOptions The raw options
 * @param Type The Type of the array
 * @param target The Target class
 * @param pkey Key of the Property
 * @param loggerType Type to use for logging
 */
export function mapOptions(rawOptions, Type, target, pkey, loggerType) {
    var _a;
    logger.debug('mapOptions called');
    loggerType = loggerType !== null && loggerType !== void 0 ? loggerType : Type;
    /** The Object that gets returned */
    const ret = {
        inner: {},
        outer: {}
    };
    if (!(Type instanceof mongoose.Schema)) {
        loggerType = Type;
        if (getName(loggerType) in mongoose.Schema.Types) {
            logger.info('Converting "%s" to mongoose Type', getName(loggerType));
            Type = mongoose.Schema.Types[getName(loggerType)];
            /* istanbul ignore next */
            if (Type === mongoose.Schema.Types.Mixed) {
                warnMixed(target, pkey);
            }
        }
    }
    if (isNullOrUndefined(loggerType)) {
        logger.info('mapOptions loggerType is undefined!');
    }
    /** The OptionsConstructor to use */
    let OptionsCTOR = (_a = Type === null || Type === void 0 ? void 0 : Type.prototype) === null || _a === void 0 ? void 0 : _a.OptionsConstructor;
    // Fix because "Schema" is not a valid type and doesn't have a ".prototype.OptionsConstructor"
    if (Type instanceof mongoose.Schema) {
        // TODO: remove "as any" cast if "OptionsConstructor" is implemented in @types/mongoose
        OptionsCTOR = mongoose.Schema.Types.Embedded.prototype.OptionsConstructor;
    }
    if (isNullOrUndefined(OptionsCTOR)) {
        throw new TypeError(`Type does not have an valid "OptionsConstructor"! (${getName(loggerType)} on ${getName(target)}.${pkey})`);
    }
    const options = Object.assign({}, rawOptions); // for sanity
    delete options.items;
    // "mongoose as any" is because the types package does not yet have an entry for "SchemaTypeOptions"
    // TODO: remove "as any" cast if "OptionsConstructor" is implemented in @types/mongoose
    if (OptionsCTOR.prototype instanceof mongoose.SchemaTypeOptions) {
        for (const [key, value] of Object.entries(options)) {
            if (Object.getOwnPropertyNames(OptionsCTOR.prototype).includes(key)) {
                ret.inner[key] = value;
            }
            else {
                ret.outer[key] = value;
            }
        }
    }
    else {
        if (loggerType) {
            logger.info('The Type "%s" has a property "OptionsConstructor" but it does not extend "SchemaTypeOptions"', getName(loggerType));
        }
        ret.outer = options;
    }
    if (typeof (options === null || options === void 0 ? void 0 : options.innerOptions) === 'object') {
        delete ret.outer.innerOptions;
        for (const [key, value] of Object.entries(options.innerOptions)) {
            ret.inner[key] = value;
        }
    }
    if (typeof (options === null || options === void 0 ? void 0 : options.outerOptions) === 'object') {
        delete ret.outer.outerOptions;
        for (const [key, value] of Object.entries(options.outerOptions)) {
            ret.outer[key] = value;
        }
    }
    if (loggerType) {
        logger.debug('Final mapped Options for Type "%s"', getName(loggerType), ret);
    }
    return ret;
}
/**
 * Warn, Error or Allow if an mixed type is set
 * -> this function exists for de-duplication
 * @param target Target Class
 * @param key Property key
 */
export function warnMixed(target, key) {
    var _a, _b;
    const name = getName(target);
    const modelOptions = (_a = Reflect.getMetadata(DecoratorKeys.ModelOptions, getRightTarget(target))) !== null && _a !== void 0 ? _a : {};
    switch ((_b = modelOptions === null || modelOptions === void 0 ? void 0 : modelOptions.options) === null || _b === void 0 ? void 0 : _b.allowMixed) {
        default:
        case Severity.WARN:
            logger.warn('Setting "Mixed" for property "%s.%s"\nLook here for how to disable this message: https://typegoose.github.io/typegoose/docs/api/decorators/modelOptions/#allowmixed', name, key);
            break;
        case Severity.ALLOW:
            break;
        case Severity.ERROR:
            throw new TypeError(format('Setting "Mixed" is not allowed! (%s, %s)', name, key));
    }
    return; // always return, if "allowMixed" is not "ERROR"
}
/**
 * Because since node 4.0.0 the internal util.is* functions got deprecated
 * @param val Any value to test if null or undefined
 */
export function isNullOrUndefined(val) {
    return val === null || val === undefined;
}
/**
 * Assign Global ModelOptions if not already existing
 * @param target Target Class
 */
export function assignGlobalModelOptions(target) {
    if (isNullOrUndefined(Reflect.getMetadata(DecoratorKeys.ModelOptions, target))) {
        logger.info('Assigning global Schema Options to "%s"', getName(target));
        assignMetadata(DecoratorKeys.ModelOptions, omit(globalOptions, 'globalOptions'), target);
    }
}
/**
 * Loop over "dimensions" and create an array from that
 * @param rawOptions baseProp's rawOptions
 * @param extra What is actually in the deepest array
 * @param name name of the target for better error logging
 * @param key key of target-key for better error logging
 */
export function createArrayFromDimensions(rawOptions, extra, name, key) {
    // dimensions start at 1 (not 0)
    const dim = typeof rawOptions.dim === 'number' ? rawOptions.dim : 1;
    if (dim < 1) {
        throw new RangeError(format('"dim" needs to be higher than 0 (%s.%s)', name, key));
    }
    delete rawOptions.dim; // delete this property to not actually put it as an option
    logger.info('createArrayFromDimensions called with %d dimensions', dim);
    let retArray = Array.isArray(extra) ? extra : [extra];
    // index starts at 1 because "retArray" is already once wrapped in an array
    for (let index = 1; index < dim; index++) {
        retArray = [retArray];
    }
    return retArray;
}
/**
 * Assert an condition, if "false" throw error
 * Note: it is not named "assert" to differentiate between node and jest types
 * @param cond The Condition to throw
 * @param error An Custom Error to throw
 */
export function assertion(cond, error) {
    if (!cond) {
        throw error !== null && error !== void 0 ? error : new Error('Assert failed - no custom error');
    }
}
/**
 * Assert if val is an function (constructor for classes)
 * @param val Value to test
 */
export function assertionIsClass(val) {
    assertion(typeof val === 'function', new NoValidClass(val));
}
/**
 * Get Type, if input is an arrow-function, execute it and return the result
 * @param typeOrFunc Function or Type
 */
export function getType(typeOrFunc) {
    if (typeof typeOrFunc === 'function' && !isConstructor(typeOrFunc)) {
        return typeOrFunc();
    }
    return typeOrFunc;
}
/**
 * Is the provided input an class with an constructor?
 */
export function isConstructor(obj) {
    var _a, _b;
    return !isNullOrUndefined((_b = (_a = obj === null || obj === void 0 ? void 0 : obj.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvaW50ZXJuYWwvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDekMsT0FBTyxLQUFLLFFBQVEsTUFBTSxVQUFVLENBQUM7QUFDckMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU5QixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFheEMsT0FBTyxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUM5RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRXhDOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUFDLElBQVM7SUFDbkMsSUFBSSxRQUFPLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxJQUFJLENBQUEsS0FBSyxRQUFRLEVBQUU7UUFDbEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxPQUFPLENBQ0wsTUFBTSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDckUsbUVBQW1FO1lBQ25FLGlFQUFpRTtZQUNqRSxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ2pGLENBQUM7S0FDSDtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUFDLElBQVM7SUFDbkMsSUFBSSxRQUFPLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxJQUFJLENBQUEsS0FBSyxRQUFRLEVBQUU7UUFDbEMsMkVBQTJFO1FBQzNFLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ3pFLFFBQVEsQ0FBQyxFQUFFO2dCQUNULEtBQUssS0FBSyxDQUFDO2dCQUNYLEtBQUssTUFBTSxDQUFDO2dCQUNaLEtBQUssUUFBUSxDQUFDO2dCQUNkLEtBQUssU0FBUztvQkFDWixPQUFPLEtBQUssQ0FBQztnQkFDZjtvQkFDRSxPQUFPLElBQUksQ0FBQzthQUNmO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCwrR0FBK0c7UUFDL0csc0RBQXNEO1FBQ3RELE9BQU8sQ0FDTCxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDdkIsbUVBQW1FO1lBQ25FLGlFQUFpRTtZQUNqRSxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQ2pGLENBQUM7S0FDSDtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLFFBQVEsQ0FBQyxJQUFTLEVBQUUsT0FBZ0IsS0FBSztJQUN2RCxJQUFJLFFBQU8sSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLElBQUksQ0FBQSxLQUFLLFFBQVEsRUFBRTtRQUNsQyxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQy9CLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDckIsT0FBTyxJQUFJLEVBQUU7WUFDWCxJQUFJLElBQUksS0FBSyxRQUFRLElBQUksSUFBSSxLQUFLLE9BQU8sRUFBRTtnQkFDekMsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUNELElBQUksSUFBSSxFQUFFO2dCQUNSLE1BQU07YUFDUDtZQUNELFNBQVMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzdDLElBQUksR0FBRyxTQUFTLGFBQVQsU0FBUyx1QkFBVCxTQUFTLENBQUUsV0FBVyxDQUFDLElBQUksQ0FBQztTQUNwQztLQUNGO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxRQUFRLENBQUMsSUFBUzs7SUFDaEMsTUFBTSxJQUFJLFNBQUcsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLElBQUksbUNBQUksRUFBRSxDQUFDO0lBRTlCLE9BQU8sSUFBSSxLQUFLLFFBQVEsSUFBSSxJQUFJLEtBQUssUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztBQUN6RSxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxRQUFRLENBQUMsSUFBUzs7SUFDaEMsTUFBTSxJQUFJLFNBQUcsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLElBQUksbUNBQUksRUFBRSxDQUFDO0lBRTlCLE9BQU8sSUFBSSxLQUFLLFFBQVEsSUFBSSxJQUFJLEtBQUssUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztBQUN6RSxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUFDLElBQVksRUFBRSxHQUFXLEVBQUUsTUFBZ0I7SUFDdEUsTUFBTSxVQUFVLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFFLENBQUM7SUFFOUYsUUFBUSxNQUFNLEVBQUU7UUFDZCxLQUFLLFFBQVEsQ0FBQyxLQUFLO1lBQ2pCLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZCLE1BQU07UUFDUixLQUFLLFFBQVEsQ0FBQyxHQUFHLENBQUM7UUFDbEIsS0FBSyxRQUFRLENBQUMsSUFBSTtZQUNoQixVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ3JCLE1BQU07UUFDUjtZQUNFLDBCQUEwQixDQUFDLGlGQUFpRjtZQUM1RyxNQUFNLElBQUksU0FBUyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7S0FDaEY7SUFFRCxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG1CQUFtQixDQUFDLFFBQTJCO0lBQzdELE1BQU0sU0FBUyxHQUFJLFFBQVEsQ0FBQyxXQUErQyxDQUFDLFNBQVMsQ0FBQztJQUV0RixPQUFPLFlBQVksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDckMsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxRQUFRLENBQ3RCLEtBS087SUFFUCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUM3QixPQUFPLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDaEM7SUFDRCxJQUFJLFFBQU8sS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLGFBQWEsQ0FBQSxLQUFLLFFBQVEsRUFBRTtRQUM1QyxPQUFPLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0tBQzlDO0lBRUQsSUFBSSxRQUFPLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxhQUFhLENBQUEsS0FBSyxVQUFVLEVBQUU7UUFDOUMsT0FBTyxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO0tBQ2hEO0lBRUQsTUFBTSxJQUFJLGNBQWMsQ0FBQyx3R0FBd0csQ0FBQyxDQUFDO0FBQ3JJLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsT0FBNkI7O0lBQ2hFLE9BQU8sQ0FBQyxpQkFBaUIsYUFBQyxPQUFPLENBQUMsS0FBSyxtQ0FBSSxPQUFPLENBQUMsU0FBUyxtQ0FBSSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDckYsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxxQkFBcUIsQ0FBQyxPQUE2Qjs7SUFDakUsT0FBTyxDQUFDLGlCQUFpQixhQUFDLE9BQU8sQ0FBQyxTQUFTLG1DQUFJLE9BQU8sQ0FBQyxTQUFTLG1DQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNwRixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUFDLE9BQTZCOztJQUNoRSxPQUFPLENBQUMsaUJBQWlCLE9BQUMsT0FBTyxDQUFDLEdBQUcsbUNBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3hELENBQUM7QUFFRCxNQUFNLGNBQWMsR0FBRyxDQUFDLFlBQVksRUFBRSxjQUFjLENBQUMsQ0FBQztBQUV0RDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsT0FBWTtJQUMzQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEUsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyw4QkFBOEI7QUFDeEYsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBRTlCOzs7R0FHRztBQUNILE1BQU0sVUFBVSxxQkFBcUIsQ0FBQyxPQUF1QjtJQUMzRCxPQUFPLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxRSxDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxjQUFjLENBQUMsR0FBa0IsRUFBRSxLQUFjLEVBQUUsRUFBZ0I7SUFDakYsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUM1QixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDL0MsT0FBTyxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRTFDLE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBVSxHQUFrQixFQUFFLEtBQWMsRUFBRSxFQUFnQjtJQUN6RixTQUFTLENBQUMsT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFLElBQUksU0FBUyxDQUFDLElBQUksR0FBRyx5Q0FBeUMsQ0FBQyxDQUFDLENBQUM7SUFDcEcsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUM7SUFFckIsaUhBQWlIO0lBQ2pILE9BQU8sU0FBUyxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQ2hILFlBQVksQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQzdCLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsWUFBWSxDQUFDLEdBQW9CLEVBQUUsR0FBWTtJQUN0RCxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtRQUMzQixPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUNELElBQUkseUNBQXlDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3ZELE9BQU8sR0FBRyxDQUFDO0tBQ1o7SUFFRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxrQkFBa0IsQ0FBcUMsS0FBeUMsRUFBRSxFQUFLO0lBQ3JILE9BQU8sYUFBYSxDQUFnQixhQUFhLENBQUMsWUFBWSxFQUFFLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLGFBQWEsQ0FBQztBQUM5RyxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxjQUFjLENBQUMsTUFBVzs7SUFDeEMsT0FBTyxPQUFBLE1BQU0sQ0FBQyxXQUFXLDBDQUFFLElBQUksTUFBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQztBQUMvRSxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxPQUFPLENBQXFDLEVBQUs7O0lBQy9ELE1BQU0sSUFBSSxHQUFRLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNyQyxNQUFNLE9BQU8sU0FBa0IsT0FBTyxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxtQ0FBSSxFQUFFLENBQUM7SUFDM0YsTUFBTSxRQUFRLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUVuQyxVQUFJLE9BQU8sQ0FBQyxPQUFPLDBDQUFFLGFBQWEsRUFBRTtRQUNsQyxNQUFNLE1BQU0sZUFBRyxPQUFPLENBQUMsT0FBTywwQ0FBRSxVQUFVLHlDQUFJLE9BQU8sQ0FBQyxhQUFhLDBDQUFFLFVBQVUsQ0FBQztRQUVoRixPQUFPLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxJQUFJLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7S0FDeEU7SUFFRCxJQUFJLGNBQU8sT0FBTyxDQUFDLE9BQU8sMENBQUUsVUFBVSxDQUFBLEtBQUssUUFBUSxFQUFFO1FBQ25ELElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtZQUMxQyxNQUFNLElBQUksU0FBUyxDQUFDLDhEQUE4RCxRQUFRLElBQUksQ0FBQyxDQUFDO1NBQ2pHO1FBRUQsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQztLQUNuQztJQUVELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUFDLEVBQU87SUFDbEMsT0FBTyxDQUNMLE9BQU8sRUFBRSxLQUFLLFVBQVU7V0FDckIsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDO1dBQ2hCLEVBQUUsS0FBSyxNQUFNO1dBQ2IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUM3QixDQUFDO0FBQ0osQ0FBQztBQUVEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBTSxVQUFVLGVBQWUsQ0FDN0IsVUFBZSxFQUNmLElBQWdELEVBQ2hELE1BQVcsRUFDWCxJQUFZLEVBQ1osVUFBcUM7SUFFckMsTUFBTSxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0lBQ3ZDLFVBQVUsR0FBRyxVQUFVLGFBQVYsVUFBVSxjQUFWLFVBQVUsR0FBSSxJQUFnQyxDQUFDO0lBRTVELElBQUksQ0FBQyxDQUFDLElBQUksWUFBWSxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDdEMsVUFBVSxHQUFHLElBQUksQ0FBQztLQUNuQjtJQUVELE1BQU0sTUFBTSxHQUFHLFVBQVUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFdEUsb0NBQW9DO0lBQ3BDLE1BQU0sWUFBWSxtQ0FDYixNQUFNLENBQUMsS0FBSyxLQUNmLElBQUksRUFBRTs0QkFFRixJQUFJLEVBQUUsSUFBSSxJQUNQLE1BQU0sQ0FBQyxLQUFLO1NBRWxCLEdBQ0YsQ0FBQztJQUVGLFlBQVksQ0FBQyxJQUFJLEdBQUcseUJBQXlCLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBRXBHLElBQUksVUFBVSxFQUFFO1FBQ2QsTUFBTSxDQUFDLEtBQUssQ0FBQyw0Q0FBNEMsRUFBRSxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUM7S0FDL0Y7SUFFRCxPQUFPLFlBQVksQ0FBQztBQUN0QixDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxVQUFVLENBQ3hCLFVBQWUsRUFDZixJQUErRCxFQUMvRCxNQUFXLEVBQ1gsSUFBWSxFQUNaLFVBQXFDOztJQUVyQyxNQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDbEMsVUFBVSxHQUFHLFVBQVUsYUFBVixVQUFVLGNBQVYsVUFBVSxHQUFJLElBQWdDLENBQUM7SUFFNUQsb0NBQW9DO0lBQ3BDLE1BQU0sR0FBRyxHQUFHO1FBQ1YsS0FBSyxFQUFFLEVBQWtCO1FBQ3pCLEtBQUssRUFBRSxFQUFrQjtLQUMxQixDQUFDO0lBRUYsSUFBSSxDQUFDLENBQUMsSUFBSSxZQUFZLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUN0QyxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2hELE1BQU0sQ0FBQyxJQUFJLENBQUMsa0NBQWtDLEVBQUUsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDckUsSUFBSSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBRWxELDBCQUEwQjtZQUMxQixJQUFJLElBQUksS0FBSyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUU7Z0JBQ3hDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDekI7U0FDRjtLQUNGO0lBRUQsSUFBSSxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUNqQyxNQUFNLENBQUMsSUFBSSxDQUFDLHFDQUFxQyxDQUFDLENBQUM7S0FDcEQ7SUFFRCxvQ0FBb0M7SUFDcEMsSUFBSSxXQUFXLFNBQXlDLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxTQUFTLDBDQUFFLGtCQUFrQixDQUFDO0lBRTVGLDhGQUE4RjtJQUM5RixJQUFJLElBQUksWUFBWSxRQUFRLENBQUMsTUFBTSxFQUFFO1FBQ25DLHVGQUF1RjtRQUN2RixXQUFXLEdBQUksUUFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUM7S0FDcEY7SUFFRCxJQUFJLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQ2xDLE1BQU0sSUFBSSxTQUFTLENBQUMsc0RBQXNELE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztLQUNqSTtJQUVELE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsYUFBYTtJQUM1RCxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUM7SUFFckIsb0dBQW9HO0lBQ3BHLHVGQUF1RjtJQUN2RixJQUFJLFdBQVcsQ0FBQyxTQUFTLFlBQWEsUUFBZ0IsQ0FBQyxpQkFBaUIsRUFBRTtRQUN4RSxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUNsRCxJQUFJLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNuRSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQzthQUN4QjtpQkFBTTtnQkFDTCxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQzthQUN4QjtTQUNGO0tBQ0Y7U0FBTTtRQUNMLElBQUksVUFBVSxFQUFFO1lBQ2QsTUFBTSxDQUFDLElBQUksQ0FBQyw4RkFBOEYsRUFBRSxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUNsSTtRQUVELEdBQUcsQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDO0tBQ3JCO0lBRUQsSUFBSSxRQUFPLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxZQUFZLENBQUEsS0FBSyxRQUFRLEVBQUU7UUFDN0MsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQztRQUM5QixLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDL0QsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7U0FDeEI7S0FDRjtJQUNELElBQUksUUFBTyxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsWUFBWSxDQUFBLEtBQUssUUFBUSxFQUFFO1FBQzdDLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUM7UUFDOUIsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQy9ELEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQ3hCO0tBQ0Y7SUFFRCxJQUFJLFVBQVUsRUFBRTtRQUNkLE1BQU0sQ0FBQyxLQUFLLENBQUMsb0NBQW9DLEVBQUUsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0tBQzlFO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFDLE1BQVcsRUFBRSxHQUFvQjs7SUFDekQsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdCLE1BQU0sWUFBWSxTQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLFlBQVksRUFBRSxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsbUNBQUksRUFBRSxDQUFDO0lBRW5HLGNBQVEsWUFBWSxhQUFaLFlBQVksdUJBQVosWUFBWSxDQUFFLE9BQU8sMENBQUUsVUFBVSxFQUFFO1FBQ3pDLFFBQVE7UUFDUixLQUFLLFFBQVEsQ0FBQyxJQUFJO1lBQ2hCLE1BQU0sQ0FBQyxJQUFJLENBQUMscUtBQXFLLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBRTlMLE1BQU07UUFDUixLQUFLLFFBQVEsQ0FBQyxLQUFLO1lBQ2pCLE1BQU07UUFDUixLQUFLLFFBQVEsQ0FBQyxLQUFLO1lBQ2pCLE1BQU0sSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLDBDQUEwQyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ3RGO0lBRUQsT0FBTyxDQUFDLGdEQUFnRDtBQUMxRCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLGlCQUFpQixDQUFDLEdBQVk7SUFDNUMsT0FBTyxHQUFHLEtBQUssSUFBSSxJQUFJLEdBQUcsS0FBSyxTQUFTLENBQUM7QUFDM0MsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSx3QkFBd0IsQ0FBQyxNQUFXO0lBQ2xELElBQUksaUJBQWlCLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUU7UUFDOUUsTUFBTSxDQUFDLElBQUksQ0FBQyx5Q0FBeUMsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN4RSxjQUFjLENBQUMsYUFBYSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLGVBQWUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQzFGO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSx5QkFBeUIsQ0FBQyxVQUFlLEVBQUUsS0FBVSxFQUFFLElBQVksRUFBRSxHQUFXO0lBQzlGLGdDQUFnQztJQUNoQyxNQUFNLEdBQUcsR0FBRyxPQUFPLFVBQVUsQ0FBQyxHQUFHLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEUsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO1FBQ1gsTUFBTSxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMseUNBQXlDLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7S0FDcEY7SUFDRCxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQywyREFBMkQ7SUFDbEYsTUFBTSxDQUFDLElBQUksQ0FBQyxxREFBcUQsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUV4RSxJQUFJLFFBQVEsR0FBVSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0QsMkVBQTJFO0lBQzNFLEtBQUssSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUU7UUFDeEMsUUFBUSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7S0FDdkI7SUFFRCxPQUFPLFFBQWlCLENBQUM7QUFDM0IsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FBQyxJQUFTLEVBQUUsS0FBYTtJQUNoRCxJQUFJLENBQUMsSUFBSSxFQUFFO1FBQ1QsTUFBTSxLQUFLLGFBQUwsS0FBSyxjQUFMLEtBQUssR0FBSSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0tBQzdEO0FBQ0gsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxHQUFRO0lBQ3ZDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsS0FBSyxVQUFVLEVBQUUsSUFBSSxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM5RCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLE9BQU8sQ0FBQyxVQUFzQjtJQUM1QyxJQUFJLE9BQU8sVUFBVSxLQUFLLFVBQVUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUNsRSxPQUFRLFVBQW1CLEVBQUUsQ0FBQztLQUMvQjtJQUVELE9BQU8sVUFBVSxDQUFDO0FBQ3BCLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUMsR0FBUTs7SUFDcEMsT0FBTyxDQUFDLGlCQUFpQixhQUFDLEdBQUcsYUFBSCxHQUFHLHVCQUFILEdBQUcsQ0FBRSxTQUFTLDBDQUFFLFdBQVcsMENBQUUsSUFBSSxDQUFDLENBQUM7QUFDL0QsQ0FBQyJ9